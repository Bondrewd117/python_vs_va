//******************************************************************
// GMMS-Os Memristor Model in Verilog-A (Simplified)
// Generalized Mean Metastable Switch model with Ostrovskii snapback
// 
// Solo 2 terminales (p, n) - sin puertos de debug
//******************************************************************

`include "constants.vams"
`include "disciplines.vams"

module rram_v1_va(p, n);
    inout p, n;
    electrical p, n;
    electrical nX;    // Nodo interno para integración

    //==================================================================
    // Parameters
    //==================================================================
    parameter real Ron = 13000.0 from (0:inf);
    parameter real Roff = 460000.0 from (0:inf);
    parameter real tau = 60e-6 from (0:inf);
    parameter real T = 108.5 from (0:inf);
    parameter real Von_th = 0.2 from (0:inf);
    parameter real Voff = -0.1 from (-inf:0];
    parameter real Af = 1e-7 from (0:inf);
    parameter real Ar = 1e-7 from (0:inf);
    parameter real Bf = 8.0 from (0:inf);
    parameter real Br = 8.0 from (0:inf);
    parameter real phi = 0.88 from [0:1];
    parameter real Xinit = 0.0 from [0:1];
    parameter real maxslope = 1e15 from (0:inf);
    parameter real smoothing = 1e-8 from (0:inf);
    parameter real Kclip = 50.0 from (0:inf);
    parameter real GMIN = 1e-12 from (0:inf);

    //==================================================================
    // Constants
    //==================================================================
    localparam real QE = 1.6e-19;
    localparam real KB = 1.38e-23;
    
    //==================================================================
    // Variables
    //==================================================================
    real X, Vm, G, Im, Is, Itotal, Von;
    real sqrtX, epsilon;
    real sig_on, sig_off, dXdt;
    real Fw1, Fw2, clip_min, clip_max;
    real cos_arg, cos_denom;

    //==================================================================
    // Functions
    //==================================================================
    
    analog function real smoothstep;
        input x, sm;
        real x, sm;
        begin
            smoothstep = 0.5 * (x / sqrt(x*x + sm) + 1.0);
        end
    endfunction
    
    analog function real safeexp;
        input x, maxsl;
        real x, maxsl, bp;
        begin
            bp = ln(maxsl);
            if (x <= bp)
                safeexp = exp(x);
            else
                safeexp = maxsl + maxsl * (x - bp);
        end
    endfunction

    analog function real safesigmoid;
        input x;
        real x;
        begin
            if (x > 35.0)
                safesigmoid = 1.0;
            else if (x < -35.0)
                safesigmoid = 0.0;
            else
                safesigmoid = 1.0 / (1.0 + exp(-x));
        end
    endfunction

    //==================================================================
    // Main Block
    //==================================================================
    analog begin
        
        // Estado y voltaje
        X = V(nX, n);
        Vm = V(p, n);
        epsilon = QE / (KB * T);
        
        // Ostrovskii snapback para Von
        if (X < 1e-9)
            sqrtX = 1e-4;
        else
            sqrtX = sqrt(X);
        
        cos_denom = 1.7 - X;
        
        if (cos_denom > 0.01) begin
            cos_arg = 4.0 * `M_PI * sqrtX / cos_denom;
            Von = Von_th + (0.1 * cos(cos_arg)) / (1.0 + 10.0 * sqrtX);
        end else begin
            Von = Von_th;
        end
        
        // GMMS state equation
        sig_on = safesigmoid(epsilon * (Vm - Von));
        sig_off = safesigmoid(epsilon * (Vm - Voff));
        dXdt = (1.0/tau) * ((1.0 - X) * sig_on - X * (1.0 - sig_off));
        
        // Soft clipping
        Fw1 = smoothstep(-X, smoothing);
        Fw2 = smoothstep(X - 1.0, smoothing);
        clip_min = (safeexp(Kclip * (-X), maxslope) - dXdt) * Fw1;
        clip_max = (-safeexp(Kclip * (X - 1.0), maxslope) - dXdt) * Fw2;
        
        // Conductancia y corrientes
        G = X / Ron + (1.0 - X) / Roff;
        Im = Vm * G;
        Is = Af * safeexp(Bf * Vm, maxslope) - Ar * safeexp(Br * Vm, maxslope);
        Itotal = phi * Im + (1.0 - phi) * Is;
        
        // Output
        I(p, n) <+ Itotal + GMIN * Vm;
        
        // Integración
        I(nX, n) <+ dXdt + clip_min + clip_max;
        I(nX, n) <+ ddt(-1.0 * X);
        
    end

endmodule